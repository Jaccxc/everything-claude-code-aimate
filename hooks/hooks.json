{
  "$schema": "https://json.schemastore.org/claude-code-settings.json",
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "tool == \"Bash\" && tool_input.command matches \"git push\"",
        "hooks": [
          {
            "type": "command",
            "command": "python -c \"import sys; sys.stderr.write('[Hook] Review changes before push...\\n[Hook] Continuing with push (remove this hook to add interactive review)\\n')\""
          }
        ],
        "description": "Reminder before git push to review changes"
      },
      {
        "matcher": "tool == \"Write\" && tool_input.file_path matches \"\\\\.(md|txt)$\" && !(tool_input.file_path matches \"README\\\\.md|CLAUDE\\\\.md|AGENTS\\\\.md|CONTRIBUTING\\\\.md\")",
        "hooks": [
          {
            "type": "command",
            "command": "python -c \"import sys, json; d=sys.stdin.read(); i=json.loads(d) if d.strip() else {}; p=i.get('tool_input',{}).get('file_path',''); import re; (sys.stderr.write(f'[Hook] BLOCKED: Unnecessary documentation file creation\\n[Hook] File: {p}\\n[Hook] Use README.md for documentation instead\\n'), sys.exit(1)) if re.search(r'\\.(md|txt)$', p) and not re.search(r'(README|CLAUDE|AGENTS|CONTRIBUTING)\\.md$', p) else print(d)\""
          }
        ],
        "description": "Block creation of random .md files - keeps docs consolidated"
      },
      {
        "matcher": "tool == \"Edit\" || tool == \"Write\"",
        "hooks": [
          {
            "type": "command",
            "command": "python \"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/suggest_compact.py\""
          }
        ],
        "description": "Suggest manual compaction at logical intervals"
      }
    ],
    "PreCompact": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "command",
            "command": "python \"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/pre_compact.py\""
          }
        ],
        "description": "Save state before context compaction"
      }
    ],
    "SessionStart": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "command",
            "command": "python \"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/session_start.py\""
          }
        ],
        "description": "Load previous context and detect project type on new session"
      }
    ],
    "PostToolUse": [
      {
        "matcher": "tool == \"Edit\" && tool_input.file_path matches \"\\\\.py$\"",
        "hooks": [
          {
            "type": "command",
            "command": "python -c \"import subprocess, json, sys, os; d=sys.stdin.read(); i=json.loads(d) if d.strip() else {}; p=i.get('tool_input',{}).get('file_path',''); subprocess.run(['poetry', 'run', 'ruff', 'format', p], capture_output=True) if p and os.path.exists(p) else None; subprocess.run(['poetry', 'run', 'black', p], capture_output=True) if p and os.path.exists(p) else None; print(d)\""
          }
        ],
        "description": "Auto-format Python files with ruff and black after edits"
      },
      {
        "matcher": "tool == \"Edit\" && tool_input.file_path matches \"\\\\.py$\"",
        "hooks": [
          {
            "type": "command",
            "command": "python -c \"import subprocess, json, sys, os; d=sys.stdin.read(); i=json.loads(d) if d.strip() else {}; p=i.get('tool_input',{}).get('file_path',''); r=subprocess.run(['poetry', 'run', 'ruff', 'check', p], capture_output=True, text=True) if p and os.path.exists(p) else None; sys.stderr.write(r.stdout[:500]) if r and r.stdout else None; print(d)\""
          }
        ],
        "description": "Ruff lint check after editing Python files"
      },
      {
        "matcher": "tool == \"Edit\" && tool_input.file_path matches \"\\\\.py$\"",
        "hooks": [
          {
            "type": "command",
            "command": "python -c \"import json, sys, os; d=sys.stdin.read(); i=json.loads(d) if d.strip() else {}; p=i.get('tool_input',{}).get('file_path',''); c=open(p).read() if p and os.path.exists(p) else ''; lines=c.split('\\n'); matches=[(n+1,l.strip()) for n,l in enumerate(lines) if 'print(' in l and not l.strip().startswith('#')]; [sys.stderr.write(f'{p}:{n}: {l}\\n') for n,l in matches[:5]] if matches else None; sys.stderr.write('[Hook] Consider removing print() or using logger\\n') if matches else None; print(d)\""
          }
        ],
        "description": "Warn about print() statements after edits"
      }
    ],
    "Stop": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "command",
            "command": "python \"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/check_print.py\""
          }
        ],
        "description": "Check for print() in modified Python files after each response"
      }
    ],
    "SessionEnd": [
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "command",
            "command": "python \"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/session_end.py\""
          }
        ],
        "description": "Persist session state on end"
      },
      {
        "matcher": "*",
        "hooks": [
          {
            "type": "command",
            "command": "python \"${CLAUDE_PLUGIN_ROOT}/scripts/hooks/evaluate_session.py\""
          }
        ],
        "description": "Evaluate session for extractable patterns"
      }
    ]
  }
}
